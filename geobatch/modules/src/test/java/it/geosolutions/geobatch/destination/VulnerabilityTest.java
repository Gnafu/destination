/*
 *  fra2015
 *  https://github.com/geosolutions-it/fra2015
 *  Copyright (C) 2007-2012 GeoSolutions S.A.S.
 *  http://www.geo-solutions.it
 *
 *  GPLv3 + Classpath exception
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package it.geosolutions.geobatch.destination;

import it.geosolutions.geobatch.destination.vulnerability.VulnerabilityComputation;
import it.geosolutions.geobatch.flow.event.ProgressListenerForwarder;
import it.geosolutions.process.gs.MultipleBuffer;

import java.awt.RenderingHints;
import java.awt.image.RenderedImage;
import java.io.File;
import java.io.IOException;
import java.io.Serializable;
import java.util.HashMap;
import java.util.Map;

import javax.imageio.ImageIO;
import javax.imageio.stream.ImageInputStream;
import javax.media.jai.JAI;
import javax.media.jai.ParameterBlockJAI;
import javax.media.jai.PlanarImage;
import javax.media.jai.ROI;
import javax.media.jai.RenderedOp;

import org.geotools.data.simple.SimpleFeatureCollection;
import org.geotools.data.simple.SimpleFeatureIterator;
import org.geotools.feature.DefaultFeatureCollection;
import org.geotools.feature.simple.SimpleFeatureBuilder;
import org.geotools.feature.simple.SimpleFeatureTypeBuilder;
import org.geotools.gce.geotiff.GeoTiffReader;
import org.geotools.geometry.jts.JTS;
import org.jaitools.imageutils.ROIGeometry;
import org.jaitools.media.jai.zonalstats.Result;
import org.jaitools.media.jai.zonalstats.ZonalStats;
import org.jaitools.media.jai.zonalstats.ZonalStatsDescriptor;
import org.jaitools.numeric.Statistic;
import org.junit.Test;
import org.opengis.feature.simple.SimpleFeature;
import org.opengis.geometry.MismatchedDimensionException;
import org.opengis.referencing.datum.PixelInCell;
import org.opengis.referencing.operation.MathTransform;
import org.opengis.referencing.operation.TransformException;

import com.sun.media.jai.operator.ImageReadDescriptor;
import com.vividsolutions.jts.geom.Coordinate;
import com.vividsolutions.jts.geom.Geometry;
import com.vividsolutions.jts.geom.GeometryFactory;
import com.vividsolutions.jts.geom.LinearRing;
import com.vividsolutions.jts.geom.Polygon;
import com.vividsolutions.jts.io.ParseException;
import com.vividsolutions.jts.io.WKTReader;

import junit.framework.TestCase;

/**
 * @author DamianoG
 *
 */
public class VulnerabilityTest  extends TestCase {

    private static final String imageURL = "C:\\Users\\geosolutions\\Documents\\destination\\targets_raster\\RP_BNU-APROT_20121218.tif";
    
    @Test
    public void testVulnerabilityProcess(){
        computeVulnerability();
    }
    
    public static void main(String [] args){
        computeVulnerability();
    }
    
    public static void computeVulnerability(){
        Map<String, Serializable> datastoreParams = new HashMap<String, Serializable>();
        datastoreParams.put("port", 5432);
        datastoreParams.put("schema", "siig_p");
        datastoreParams.put("passwd", "siig_p");
        datastoreParams.put("dbtype", "postgis");
        datastoreParams.put("host", "192.168.88.132");
        datastoreParams.put("Expose primary keys", "true");
        datastoreParams.put("user", "siig_p");
        datastoreParams.put("database", "destination_staging");
        VulnerabilityComputation vulnerabilityComputation = new VulnerabilityComputation("siig_geo_ln_arco_1", new ProgressListenerForwarder(null));
        try {
            vulnerabilityComputation.computeVulnerability(datastoreParams, null, 1);
        } catch (IOException e) {
        }
    }

    public void testBuffer1() throws IOException {

        SimpleFeatureCollection features = createFeature();
        Double[] distances = new Double[] { 1.0 };
        MultipleBuffer buffers = new MultipleBuffer();
        String[] distanceNames = new String[] { "distance1", };
        SimpleFeatureCollection outputCollection = buffers.execute(features, null, null, distances,
                distanceNames);

        Geometry the_geom = null;

        SimpleFeatureIterator iter = outputCollection.features();
        while (iter.hasNext()) {
            SimpleFeature feature = iter.next();
            the_geom = (Geometry) feature.getDefaultGeometry();
            System.out.println(the_geom.getArea());
        }
        
        RenderedImage myData = createConstantImage();
        ROI roi = new ROIGeometry(the_geom);

        ParameterBlockJAI pb = new ParameterBlockJAI("ZonalStats");
        pb.setSource("dataImage", myData);
        // pb.setSource("zoneImage", myZones);
        pb.setParameter("roi", roi);

        Statistic[] stats = { Statistic.SUM, };

        pb.setParameter("stats", stats);
        RenderedOp op = JAI.create("ZonalStats", pb);

        ZonalStats res = (ZonalStats) op.getProperty(ZonalStatsDescriptor.ZONAL_STATS_PROPERTY);

        // print results to console
        for (Result r : res.results()) {
            System.out.println(r);
        }
        
    }

    public void testBuffer2() throws IOException, ParseException, MismatchedDimensionException, TransformException {

        Geometry geom = createGeom();
        RenderedImage myData = loadImage(true, new File(imageURL));
        
        GeoTiffReader gtr = new GeoTiffReader(new File(imageURL));
        // get the world to grid matrix
        MathTransform g2w = gtr.getOriginalGridToWorld(PixelInCell.CELL_CORNER); // TODO Corner or Center?
        MathTransform w2g = g2w.inverse();
        Geometry targetGeom = JTS.transform(geom, w2g);
        
        Double[] distances = new Double[] { 200.0, 300.0, 400.0, 500.0 };
        MultipleBuffer buffers = new MultipleBuffer();
        String[] distanceNames = new String[] { "distance1", "distance2", "distance3", "distance4" };
        
        
        SimpleFeatureTypeBuilder tb = new SimpleFeatureTypeBuilder();
        tb.setName("featureType");
        tb.add("geometry", Geometry.class);
        tb.add("integer", Integer.class);
        SimpleFeatureBuilder b = new SimpleFeatureBuilder(tb.buildFeatureType());
        DefaultFeatureCollection features = new DefaultFeatureCollection(null, b.getFeatureType());
        b.add(targetGeom);
        b.add(0);
        features.add(b.buildFeature("piemontelinestring"));
        
        SimpleFeatureCollection outputCollection = buffers.execute(features, null, null, distances,
                distanceNames);

        Geometry the_geom = null;
        Geometry the_geom2 = null;
        Geometry the_geom3 = null;
        Geometry the_geom4 = null;

        SimpleFeatureIterator iter = outputCollection.features();
        while (iter.hasNext()) {

            SimpleFeature feature = iter.next();

            the_geom = (Geometry) feature.getDefaultGeometry();
            System.out.println(the_geom.getArea());

            // the_geom1 = (Geometry)feature.getAttribute("geometry1");
            // System.out.println(the_geom1.getArea());

            the_geom2 = (Geometry) feature.getAttribute("geometry2");
            System.out.println(the_geom2.getArea());

            the_geom3 = (Geometry) feature.getAttribute("geometry3");
            System.out.println(the_geom3.getArea());

            the_geom4 = (Geometry) feature.getAttribute("geometry4");
            System.out.println(the_geom4.getArea());

        }

        
        ROI roi = new ROIGeometry(the_geom);

        ParameterBlockJAI pb = new ParameterBlockJAI("ZonalStats");
        pb.setSource("dataImage", myData);
        // pb.setSource("zoneImage", myZones);
        pb.setParameter("roi", roi);

        Statistic[] stats = { Statistic.SUM, };

        pb.setParameter("stats", stats);
        RenderedOp op = JAI.create("ZonalStats", pb);

        ZonalStats res = (ZonalStats) op.getProperty(ZonalStatsDescriptor.ZONAL_STATS_PROPERTY);

        // print results to console
        for (Result r : res.results()) {
            System.out.println(r);
        }
    }

    private static SimpleFeatureCollection createFeature() {

        SimpleFeatureTypeBuilder tb = new SimpleFeatureTypeBuilder();
        tb.setName("featureType");
        tb.add("geometry", Geometry.class);
        tb.add("integer", Integer.class);

        GeometryFactory gf = new GeometryFactory();

        SimpleFeatureBuilder b = new SimpleFeatureBuilder(tb.buildFeatureType());
        DefaultFeatureCollection features = new DefaultFeatureCollection(null, b.getFeatureType());

        Coordinate array[] = new Coordinate[5];
        array[0] = new Coordinate(1, 1);
        array[1] = new Coordinate(1, 2);
        array[2] = new Coordinate(2, 2);
        array[3] = new Coordinate(2, 1);
        array[4] = new Coordinate(1, 1);
        LinearRing lr = gf.createLinearRing(array);
        Polygon p = gf.createPolygon(lr, null);
        b.add(p);
        features.add(b.buildFeature("1"));

        return features;
    }

    private static Geometry createGeom() throws ParseException {

        WKTReader wktReader = new WKTReader();
        Geometry sourceGeom = wktReader.read("LINESTRING(359136 5047674, 380407 5047590, 380995 5036492)");
        
        return sourceGeom;
    }

    /**
     * Loads a {@link RenderedImage} from the specified file with the specified mode.
     * 
     * @param mode, {@link ComputationMode} can be {@link ComputationMode#DEFERRED} or {@link ComputationMode#IMMEDIATE} as per the JAI meaning.
     * @param tiffFile the input {@link File} where to read from.
     * 
     * @return
     * @throws IOException in case the creation of the {@link ImageInputStream} or the Immediate read with Imageio fails.
     */
    private static RenderedImage loadImage(boolean deferred, File tiffFile) throws IOException {
        // checks
        if (!tiffFile.isFile() || !tiffFile.exists() || !tiffFile.canRead()) {
            throw new IllegalArgumentException("Unable to load image from file: "
                    + tiffFile.getAbsolutePath() + "\n" + "isFile=" + tiffFile.isFile() + "\n"
                    + "exists=" + tiffFile.exists() + "\n" + "canRead=" + tiffFile.canRead());
        }

        if (deferred) {
            final ImageInputStream inStream = ImageIO.createImageInputStream(tiffFile);
            if (inStream == null) {
                throw new IllegalArgumentException("Unable to create input stream from file: "
                        + tiffFile.getAbsolutePath() + "\n" + "isFile=" + tiffFile.isFile() + "\n"
                        + "exists=" + tiffFile.exists() + "\n" + "canRead=" + tiffFile.canRead());
            }
            return ImageReadDescriptor.create(inStream, Integer.valueOf(0), false, false, false,
                    null, null, null, null, null);
        } else {
            return ImageIO.read(tiffFile);

        }

    }

    private static PlanarImage createConstantImage() {

        RenderingHints hints = null;

        ParameterBlockJAI pb = new ParameterBlockJAI("constant");
        pb.setParameter("width", 128f);
        pb.setParameter("height", 128f);
        pb.setParameter("bandValues", new Double[] { 1.0 });

        return JAI.create("constant", pb, hints).getRendering();
    }

}
