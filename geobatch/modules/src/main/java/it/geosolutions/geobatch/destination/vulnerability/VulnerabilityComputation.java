/*
 *  https://github.com/geosolutions-it/fra2015
 *  Copyright (C) 2007-2012 GeoSolutions S.A.S.
 *  http://www.geo-solutions.it
 *
 *  GPLv3 + Classpath exception
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package it.geosolutions.geobatch.destination.vulnerability;
/*
 *  https://github.com/geosolutions-it/fra2015
 *  Copyright (C) 2007-2012 GeoSolutions S.A.S.
 *  http://www.geo-solutions.it
 *
 *  GPLv3 + Classpath exception
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
import it.geosolutions.geobatch.destination.IngestionObject;
import it.geosolutions.geobatch.destination.OutputObject;
import it.geosolutions.geobatch.flow.event.ProgressListenerForwarder;

import java.io.File;
import java.io.IOException;
import java.io.Serializable;
import java.math.BigDecimal;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.apache.commons.lang3.tuple.Pair;
import org.geotools.data.DataUtilities;
import org.geotools.data.DefaultTransaction;
import org.geotools.data.Transaction;
import org.geotools.data.simple.SimpleFeatureCollection;
import org.geotools.data.simple.SimpleFeatureIterator;
import org.geotools.factory.Hints;
import org.geotools.feature.simple.SimpleFeatureBuilder;
import org.geotools.jdbc.JDBCDataStore;
import org.hsqldb.lib.Iterator;
import org.jaitools.media.jai.zonalstats.Result;
import org.opengis.feature.simple.SimpleFeature;
import org.opengis.feature.type.AttributeDescriptor;
import org.opengis.referencing.crs.CoordinateReferenceSystem;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.vividsolutions.jts.geom.Geometry;

/**
 * @author DamianoG
 * 
 */
public class VulnerabilityComputation extends IngestionObject {

    private final static Logger LOGGER = LoggerFactory.getLogger(VulnerabilityComputation.class);

    private static Pattern typeNameParts = Pattern.compile("siig_geo_ln_arco_([1-3]{1})");

    private static String vunerabilityTypeName = "siig_t_vulnerabilita_X";

    /**
     * @param inputTypeName
     * @param listenerForwarder
     */
    public VulnerabilityComputation(String inputTypeName,
            ProgressListenerForwarder listenerForwarder) {
        super(inputTypeName, listenerForwarder);
    }

    @Override
    protected boolean parseTypeName(String typeName) {
        Matcher m = typeNameParts.matcher(typeName);
        if (m.matches()) {
            return true;
        }
        return false;
    }

    private String getTypeName(String typeName, int aggregationLevel) {
        return typeName.replace("X", aggregationLevel + "");
    }

    public void computeVulnerability(Map<String, Serializable> datastoreParams,
            CoordinateReferenceSystem crs, int aggregationLevel) throws IOException {

        reset();
        if (isValid()) {
            JDBCDataStore dataStore = null;

            crs = checkCrs(crs);

            String outFeatureName = getTypeName(vunerabilityTypeName, aggregationLevel);

            int process = -1;
            int trace = -1;
            int errors = 0;

            dataStore = connectToDataStore(datastoreParams);
            createInputReader(dataStore, null, null);
            Transaction transaction = new DefaultTransaction();
            OutputObject vulnerabilityObj = new OutputObject(dataStore, transaction,
                    outFeatureName, "");
            OutputObject[] outputObjs = new OutputObject[] { vulnerabilityObj };

            // calculates total objects to import
            int total = getImportCount();
            int startId = ((BigDecimal) getOutputId(vulnerabilityObj)).intValue();
            Map<String, Pair<String[], Double[]>> distances = PropertiesLoaderUtils.loadDistances();
            
            try {
                SimpleFeature inputFeature = null;
                while ((inputFeature = readInput()) != null) {
                    
                    for(String el : distances.keySet()){
                        Pair<String[], Double[]> pair = distances.get(el);
                        SimpleFeatureCollection buffers = VulnerabilityUtils.computeBuffers(inputFeature, pair);
                        SimpleFeatureIterator iter = buffers.features();
                        while(iter.hasNext()){
                            SimpleFeature sf = iter.next();
                            for(int i=1; i<=pair.getLeft().length; i++){
                                int c = (Integer)((i==1)?"":i);
                                Double distance = (Double)sf.getAttribute("distance" + i);
                                Geometry geom = (Geometry)sf.getAttribute("geometry" + c);
                                String imgAbsolutePath = "";//TODO
                                Geometry roiGeom = VulnerabilityUtils.toRasterSpace(imgAbsolutePath, geom);
                                Result res = VulnerabilityUtils.sumCellsInsideBuffer(roiGeom, VulnerabilityUtils.loadImage(true, new File(imgAbsolutePath)), 0);
                                res.getValue();
                            }
                        }
                        
//                        errors = writeOutputObjects(trace, dataStore, outputObjs, total, errors,
//                                outFeatureName, inputFeature, id);
                    }
                    
                    int id = nextId(startId);
                }
                importFinished(total, "Data imported in " + outFeatureName);

            } finally {
                closeInputReader();
            }
        }
    }

    private int writeOutputObjects(int trace, JDBCDataStore dataStore,
            OutputObject[] outputObjects, int total, int errors, String outputName,
            SimpleFeature inputFeature, int id) throws IOException {
        Transaction rowTransaction = new DefaultTransaction();
        setTransaction(outputObjects, rowTransaction);

        try {
//            addVulnerabilityFeature()
            rowTransaction.commit();

            updateImportProgress(total, "Importing data in " + outputName);
        } catch (Exception e) {
            errors++;
            rollbackId();
            rowTransaction.rollback();
        } finally {
            rowTransaction.close();
        }
        return errors;
    }

    private void addVulnerabilityFeature(OutputObject vulnerabilityObject, int id /**/)
            throws IOException {

        SimpleFeatureBuilder featureBuilder = vulnerabilityObject.getBuilder();

        for (AttributeDescriptor attr : vulnerabilityObject.getSchema().getAttributeDescriptors()) {
            if (attr.getLocalName().equals("id_geo_arco")) {
                featureBuilder.add("");// TODO
            } else if (attr.getLocalName().equals("id_distanza")) {
                featureBuilder.add("");
            } else if (false) { // TODO
                // TODO;
            } else {
                featureBuilder.add(null);
            }

            String featureid = id + "." + "";// TODO
            SimpleFeature feature = featureBuilder.buildFeature(featureid);
            feature.getUserData().put(Hints.USE_PROVIDED_FID, true);

            vulnerabilityObject.getWriter().addFeatures(DataUtilities.collection(feature));
        }
    }
}
