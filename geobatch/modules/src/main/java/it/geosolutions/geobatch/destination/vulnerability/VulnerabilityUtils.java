/*
 *  Copyright (C) 2007-2012 GeoSolutions S.A.S.
 *  http://www.geo-solutions.it
 *
 *  GPLv3 + Classpath exception
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package it.geosolutions.geobatch.destination.vulnerability;

import it.geosolutions.process.gs.MultipleBuffer;

import java.awt.image.RenderedImage;
import java.awt.image.renderable.ParameterBlock;
import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.imageio.ImageIO;
import javax.imageio.stream.ImageInputStream;
import javax.media.jai.JAI;
import javax.media.jai.ParameterBlockJAI;
import javax.media.jai.ROI;
import javax.media.jai.RenderedOp;

import org.apache.commons.lang3.tuple.Pair;
import org.geotools.data.DataSourceException;
import org.geotools.data.DataUtilities;
import org.geotools.data.simple.SimpleFeatureCollection;
import org.geotools.data.simple.SimpleFeatureIterator;
import org.geotools.gce.geotiff.GeoTiffReader;
import org.geotools.geometry.jts.JTS;
import org.jaitools.imageutils.ROIGeometry;
import org.jaitools.media.jai.zonalstats.Result;
import org.jaitools.media.jai.zonalstats.ZonalStats;
import org.jaitools.media.jai.zonalstats.ZonalStatsDescriptor;
import org.jaitools.numeric.Range;
import org.jaitools.numeric.Statistic;
import org.opengis.feature.simple.SimpleFeature;
import org.opengis.referencing.datum.PixelInCell;
import org.opengis.referencing.operation.MathTransform;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.sun.media.jai.operator.ImageReadDescriptor;
import com.vividsolutions.jts.geom.Envelope;
import com.vividsolutions.jts.geom.Geometry;

/**
 * @author DamianoG
 *
 */
public class VulnerabilityUtils {

    private final static Logger LOGGER = LoggerFactory.getLogger(VulnerabilityUtils.class);
    
    public static Map<Double, Geometry> computeBuffers(SimpleFeature arc, Pair<String[], Double[]> distances){
        
        MultipleBuffer mb = new MultipleBuffer();
        SimpleFeatureCollection outputCollection = mb.execute(DataUtilities.collection(arc), null, null, distances.getRight(), distances.getLeft());
        Map<Double, Geometry> bufferMap = new HashMap<Double, Geometry>();
        SimpleFeatureIterator iter = outputCollection.features();
        while(iter.hasNext()){
            SimpleFeature sf = iter.next();
            for(int i=0; i<=distances.getLeft().length; i++){
              int indexName = i+1;
              String c = (i==0)?"":""+indexName;
              Double distance = (Double)sf.getAttribute("distance" + i);
              Geometry geom = (Geometry)sf.getAttribute("geometria" + c);
              bufferMap.put(distance, geom);
            }
        }
        return bufferMap;
    }
    
    
    /**
     * Convert originGeom into the raster space of the raster provided by its path
     *  
     * @param imageUrl the absolute path of the raster
     * @param originGeom the origin geometry to convert
     * @return
     */
    public static Geometry toRasterSpace(String imageUrl, Geometry originGeom){
        
        GeoTiffReader gtr = null;
        try {
            gtr = new GeoTiffReader(new File(imageUrl));
            // get the world to grid matrix
            MathTransform g2w = gtr.getOriginalGridToWorld(PixelInCell.CELL_CORNER);
            MathTransform w2g;
            w2g = g2w.inverse();
            if(originGeom == null)
                LOGGER.info("--> "+originGeom);
            return JTS.transform(originGeom, w2g);
        } catch (DataSourceException e) {
            LOGGER.error(e.getMessage(), e);
        } catch (Exception e) {
            LOGGER.error(e.getMessage(), e);
        }
        finally{
            if(gtr != null){    
                gtr.dispose();   
            }
        }
        return null;
    }
    
    public static Double getNoDataValue(String imageUrl){
        
        GeoTiffReader gtr = null;
        try {
            gtr = new GeoTiffReader(new File(imageUrl));
            if(!gtr.getMetadata().hasNoData()){
                return null;
            }
            return gtr.getMetadata().getNoData();
        } catch (DataSourceException e) {
            LOGGER.error(e.getMessage(), e);
        } catch (Exception e) {
            LOGGER.error(e.getMessage(), e);
        }
        finally{
            if(gtr != null){    
                gtr.dispose();   
            }
        }
        return null;
    }
    
    public static RenderedImage cropImage(RenderedImage image, Geometry roi){
        
        ParameterBlock pb = new ParameterBlock();
        pb.addSource(image);
        
        Envelope bbox = roi.getEnvelopeInternal();
        
        pb.add((float)bbox.getMinX());
        pb.add((float)bbox.getMinY());
        pb.add((float)bbox.getWidth());
        pb.add((float)bbox.getHeight());

        //Creates the cropped area
        image = JAI.create("crop", pb);
        
        return image;
    }
    
    
    /**
     * Perform the sum of the pixels of the provided raster inside the ROI and on the selected band.
     * 
     * @return the result as JaiTools Result object
     */
    public static Result sumCellsInsideBuffer(Geometry roiGeom, RenderedImage image, Double noData, int band){
        ROI roi = new ROIGeometry(roiGeom);

        ParameterBlockJAI pb = new ParameterBlockJAI("ZonalStats");
        pb.setSource("dataImage", image);
        // pb.setSource("zoneImage", myZones);
        pb.setParameter("roi", roi);

        Statistic[] stats = { Statistic.SUM, };

        pb.setParameter("stats", stats);
        pb.setParameter("bands", new Integer[] { band });
        //pb.setParameter("noData", noData);
        
        List<Range> dataNDR = null;
        if (noData != null) {
            Range nodata = new Range(noData, true, noData, true);
            dataNDR = new ArrayList<Range>();
            dataNDR.add(nodata);
            pb.setParameter("noDataRanges", dataNDR);
        }
        
        RenderedOp op = JAI.create("ZonalStats", pb);

        ZonalStats res = (ZonalStats) op.getProperty(ZonalStatsDescriptor.ZONAL_STATS_PROPERTY);

        return res.results().get(0);
    }
    
    /**
     * Loads a {@link RenderedImage} from the specified file with the specified mode.
     * 
     * @param mode, {@link ComputationMode} can be {@link ComputationMode#DEFERRED} or {@link ComputationMode#IMMEDIATE} as per the JAI meaning.
     * @param tiffFile the input {@link File} where to read from.
     * 
     * @return
     * @throws IOException in case the creation of the {@link ImageInputStream} or the Immediate read with Imageio fails.
     */
    public static RenderedImage loadImage(boolean deferred, File tiffFile) throws IOException {
        // checks
        if (!tiffFile.isFile() || !tiffFile.exists() || !tiffFile.canRead()) {
            throw new IllegalArgumentException("Unable to load image from file: "
                    + tiffFile.getAbsolutePath() + "\n" + "isFile=" + tiffFile.isFile() + "\n"
                    + "exists=" + tiffFile.exists() + "\n" + "canRead=" + tiffFile.canRead());
        }

        if (deferred) {
            final ImageInputStream inStream = ImageIO.createImageInputStream(tiffFile);
            if (inStream == null) {
                throw new IllegalArgumentException("Unable to create input stream from file: "
                        + tiffFile.getAbsolutePath() + "\n" + "isFile=" + tiffFile.isFile() + "\n"
                        + "exists=" + tiffFile.exists() + "\n" + "canRead=" + tiffFile.canRead());
            }
            return ImageReadDescriptor.create(inStream, Integer.valueOf(0), false, false, false,
                    null, null, null, null, null);
        } else {
            return ImageIO.read(tiffFile);

        }

    }
}
