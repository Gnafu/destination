/*
 *  Copyright (C) 2007-2012 GeoSolutions S.A.S.
 *  http://www.geo-solutions.it
 *
 *  GPLv3 + Classpath exception
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package it.geosolutions.geobatch.destination.vulnerability;

import static it.geosolutions.geobatch.destination.vulnerability.VulnerabilityComputation.GEOID;
import static it.geosolutions.geobatch.destination.vulnerability.VulnerabilityComputation.PARTNER_FIELD;
import it.geosolutions.geobatch.destination.OutputObject;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import org.geotools.data.DataUtilities;
import org.geotools.data.DefaultTransaction;
import org.geotools.data.Query;
import org.geotools.data.Transaction;
import org.geotools.factory.CommonFactoryFinder;
import org.geotools.factory.Hints;
import org.geotools.feature.NameImpl;
import org.geotools.feature.simple.SimpleFeatureBuilder;
import org.geotools.jdbc.JDBCDataStore;
import org.opengis.feature.simple.SimpleFeature;
import org.opengis.feature.type.AttributeDescriptor;
import org.opengis.feature.type.Name;
import org.opengis.filter.Filter;
import org.opengis.filter.FilterFactory2;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
/**
 * @author DamianoG
 * 
 * This class is responsible for persist the results of the vulnerability process into a geotools Store.
 * It provide method for save the data and method for prepare the feature store.
 * 
 * It can be instantiate through the instantiateWriter() method that given a write mode instantiate the right implementation
 * for using it in Update or Insert.  
 * 
 * TODO generalize it and use also in other processes.
 *
 */
public abstract class VulnerabilityResultsWriter {

    private final static Logger LOGGER = LoggerFactory.getLogger(VulnerabilityResultsWriter.class);
    
    public static Double DISTANCE_NOT_SET_VALUE = 0d;
    public static String DISTANCE_ID = "id_distanza";
    public static FilterFactory2 filterFactory = CommonFactoryFinder.getFilterFactory2();
    
    public enum WriteMode {INSERT, UPDATE};
    
    /**
     * return a VulnerabilityResultsWriter suitable for the provided mode.
     * By default return the more conservative mode, WriterUpdate don't remove the records for a given partner.
     * @param mode
     * @return
     */
    public static VulnerabilityResultsWriter instantiateWriter(WriteMode mode){
        if(mode == null){
            return new WriterUpdate();
        }
        switch(mode){
            case INSERT: return new WriterInsert();
            case UPDATE: return new WriterUpdate();
            default: return new WriterUpdate();
        }
    }
    
    public static VulnerabilityResultsWriter instantiateWriterFromString(String mode){
        if(mode == null){
            return instantiateWriter(null);
        }
        return instantiateWriter(VulnerabilityResultsWriter.WriteMode.valueOf(mode));
    }
    
    protected void addNewVulnerabilityFeature(OutputObject vulnerabilityObject, String id,
            Map<String, Double> map, int partner_id) throws IOException {
        
        SimpleFeatureBuilder featureBuilder = vulnerabilityObject.getBuilder();
        String[] p_key = id.split("\\.");
        for (AttributeDescriptor attr : vulnerabilityObject.getSchema().getAttributeDescriptors()) {
            if (attr.getLocalName().equals("id_geo_arco")) {
                featureBuilder.add(p_key[0]);
            } else if (attr.getLocalName().equals("id_distanza")) {
                featureBuilder.add(p_key[1]);
            } else if (attr.getLocalName().equals(PARTNER_FIELD)) {
                featureBuilder.add(partner_id+"");
            } else { 
                Double value = map.get(attr.getLocalName());
                featureBuilder.add((value == null)?DISTANCE_NOT_SET_VALUE:value);
            }
        }
        SimpleFeature feature = featureBuilder.buildFeature(id);
        feature.getUserData().put(Hints.USE_PROVIDED_FID, true);
        vulnerabilityObject.getWriter().addFeatures(DataUtilities.collection(feature));            
    }

    
    public int writeOutputObjects(int trace, JDBCDataStore dataStore,
            OutputObject outputObject, int total, int errors, String outputName,
            SimpleFeature inputFeature, String id, Map<String, Double> map, int partnerId) throws IOException {
        Transaction rowTransaction = new DefaultTransaction();
        
        outputObject.getWriter().setTransaction(rowTransaction);

        try {
            addVulnerabilityFeature(outputObject, id, map, partnerId);
            rowTransaction.commit();
            //updateImportProgress(total, "Importing data in " + outputName);
        } catch (Exception e) {
            errors++;
            rowTransaction.rollback();
        } finally {
            rowTransaction.close();
        }
        return errors;
    }
    
    /**
     * Add a new feature (or update an existing one)
     * 
     * @param vulnerabilityObject
     * @param id
     * @param map
     * @param partner_id
     * @throws IOException
     */
    protected abstract void addVulnerabilityFeature(OutputObject vulnerabilityObject, String id, Map<String, Double> map, int partner_id) throws IOException;
    
    /**
     * This method is responsible for initialize the table where the vulnerability process resilts will be stored
     * 
     * @param vulnerabilityObject
     * @param partner_id
     * @throws IOException
     */
    protected abstract void initFeature(OutputObject vulnerabilityObject, int partner_id) throws IOException;
    
    public static class WriterInsert extends VulnerabilityResultsWriter{

        @Override
        protected void addVulnerabilityFeature(OutputObject vulnerabilityObject, String id,
                Map<String, Double> map, int partnerId) throws IOException {
            
            if(LOGGER.isDebugEnabled()){
                LOGGER.debug("Insert Mode: addFeature...");
            }
            addNewVulnerabilityFeature(vulnerabilityObject, id, map, partnerId);
        }

        @Override
        protected void initFeature(OutputObject vulnerabilityObject, int partnerId)
                throws IOException {
            if(LOGGER.isDebugEnabled()){
                LOGGER.debug("Insert Mode: initFeature");
            }
            //    Setup the OutputObject (in the case the vulnerability table) remove old values for the partner and detect the max id
            Transaction transaction = new DefaultTransaction();
            try {
                    // remove previous data for the given partner
                    Filter removeFilter = filterFactory.equals(
                            filterFactory.property(PARTNER_FIELD), filterFactory.literal(partnerId)
                    );
                    vulnerabilityObject.getWriter().setTransaction(transaction);
                    vulnerabilityObject.getSource().removeFeatures(removeFilter);     
                    transaction.commit();   
            } catch (IOException e) {
                    LOGGER.error("Error while trying to delete vulnerability objects for partner " + partnerId, e);
                    transaction.rollback();
                    throw e;
            } finally {
                    transaction.close();
            }
        }        
    }
    
    public static class WriterUpdate extends VulnerabilityResultsWriter{

        @Override
        protected void addVulnerabilityFeature(OutputObject vulnerabilityObject, String id,
                Map<String, Double> map, int partnerId) throws IOException {
            
            SimpleFeatureBuilder featureBuilder = vulnerabilityObject.getBuilder();
            // get the PK (id_geoarco, distance) from FID
            String[] p_key = id.split("\\.");
            
            if(LOGGER.isDebugEnabled()){
                LOGGER.debug("Update Mode: addFeature ID: " + p_key[0] + " - " + p_key[1]);
            }
            
            // setup the filter for find if a record is already present or not
            Filter updateFilter = filterFactory.and(
                    filterFactory.equals(filterFactory.property(PARTNER_FIELD),
                            filterFactory.literal(partnerId)),
                    filterFactory.and(
                            filterFactory.equals(filterFactory.property(GEOID),
                                    filterFactory.literal(p_key[0])),
                            filterFactory.equals(filterFactory.property(DISTANCE_ID),
                                    filterFactory.literal(p_key[1]))

                    ));
            
            List<Name> attributeNamesList = new ArrayList<Name>();
            List<Object> attributeValueList = new ArrayList<Object>();
            
            Iterator iter = map.keySet().iterator();
            while(iter.hasNext()){
                String key = (String)iter.next();
                attributeNamesList.add(new NameImpl(key));
                attributeValueList.add(map.get(key));
            }
            
            // If the feature p_key is not present means that a new distance is added so insert a new row
            if(vulnerabilityObject.getReader().getCount(new Query(vulnerabilityObject.getName(), updateFilter)) <= 0){
                if(LOGGER.isDebugEnabled()){
                    LOGGER.debug("feature[" + p_key[0] + " - " + p_key[1] + "] is not present... going to insert it");
                }
                addNewVulnerabilityFeature(vulnerabilityObject, id, map, partnerId);
            }
            // Otherwise just a new target is added so update an existing record 
            else{
                if(LOGGER.isDebugEnabled()){
                    LOGGER.debug("feature[" + p_key[0] + " - " + p_key[1] + "] is already present... going to update it");
                }
                vulnerabilityObject.getWriter().modifyFeatures(attributeNamesList.toArray(new NameImpl[attributeNamesList.size()]), attributeValueList.toArray(), updateFilter);
            }
            
            
        }

        @Override
        protected void initFeature(OutputObject vulnerabilityObject, int partner_id)
                throws IOException {
            if(LOGGER.isDebugEnabled()){
                LOGGER.debug("Update Mode: initFeature... nothing to do...");
            }
        }        
    }
}
